<!-- GFM-TOC -->
* [一、redis原理](#redis原理)
* [二、reidis数据结构](#reidis数据结构)
    * [什么是事务](##什么是事务？他有什么特性？)
    * [事务隔离](##事务隔离)
* [三、锁机制](#锁机制)
* [四、索引](#索引)
* [五、分库分表](#分库分表)
    * [水平拆分](##水平拆分)
    * [垂直拆分](##垂直拆分)
<!-- GFM-TOC -->

# redis原理
redis的读写是采用了<font color=red>**单线程的 io 多路复用**</font>，那么什么是io多路复用技术？什么是io。
我们先引入一个io的流程
- 应用程序请求获取数据，用户态请求内核读取数据，然后等待内核读取数据。
- 内核把read的数据复制到用户空间。然后才能使用数据。

因为read是内核才能完成的事，用户线程在请求内核线程的时候有可能会挂起阻塞。就有了3大io模型<font color=red> **BIO,NIO,AIO,多路复用**</font>

1）**BIO**：blocking io 为同步阻塞 IO
- 应用请求数据，请求内核资源，BIO会挂起用户线程，直至内核资源空闲或数据复制完毕返回给用户线程
- 这个过程为同步阻塞
- 一个线程负责一个io读写，在并发读写情况下非常的消耗线程资源。而计算机的线程是固定的，所以在大量io会造成系统崩溃
![在这里插入图片描述](/assects/database/BIO.png)
2）**NIO**：New io为系统资源的使用提供了一套较为有效的办法，自旋和selector复用线程。
- NIO的核心思想就是多路复用。
- NIO通过Selector构建多路复用器，使用一个或少量线程监听大量socket链接。
- 通过select,poll,epoll等机制处理用户线程
![在这里插入图片描述](/assects/database/NIO.png)
3)**AIO**：异步非阻塞型io,用户链接无需等待响应，响应由回调函数通知完成
- 用户线程异步非阻塞
![在这里插入图片描述](/assects/database/AIO.jpg)

**阻塞或非阻塞**：是否需要等待资源使用。当资源没准备好而挂起线程则为阻塞，资源没准备好返回状态可以重试等操作的即为非阻塞

**同步或者异步**：是否需要等待结果集返回的，如果需要等待结果返回则为同步，如果不需要等待结果的则为异步，一般异步有回调方法，成功后由os通知用户结果。

# reidis数据结构
redis数据结构为k-v对应的数据，不同于mysql,oracle等的数据行

## String
```
>set key value
OK
>get key
value
>del key
1
```

## List

## Set

## Zset

# reidis集群机制及搭建

# redis哨兵主从复制集群

# redis订阅发布

# nosql的比较
