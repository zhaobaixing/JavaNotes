* [一、设计模式基础](#设计模式基础)
  * [设计原则](##设计原则)
    * [单一职责原则](##单一职责原则)
    * [开闭原则](##开闭原则)
    * [里氏替换原则](##里氏替换原则)
    * [依赖倒置原则](##依赖倒置原则)
    * [接口隔离原则](##接口隔离原则)
    * [迪米特原则（最少知识原则）](##迪米特原则（最少知识原则）)
* [二、23设计模式及举例](#23设计模式及举例)
  * [创建型(5种)](##创建型（5种）)
    * [工厂模式](###工厂模式)
    * [抽象工厂模式](###抽象工厂模式)
    * [单例模式](###单例模式)
    * [构造者模式](###构造者模式)
    * [原型模式](###原型模式)
  * [结构型(7种)](##设计原则(7种))
    * [适配器模式](###适配器模式)
    * [外观模式](###外观模式)
    * [桥接模式](###桥接模式)
    * [装饰器模式](###装饰器模式)
    * [代理模式](###代理模式)
    * [享元模式](###享元模式)
    * [组合模式](###组合模式)
  * [行为型(11种)](##行为型(11种))
    * [模板方法模式](###模板方法模式)
    * [策略模式](###策略模式)
    * [命令模式](###命令模式)
    * [中介者模式](###中介者模式)
    * [观察者模式](###观察者模式)
    * [迭代器模式](###迭代器模式)
    * [访问者模式](###访问者模式)
    * [责任链模式](###责任链模式)
    * [备忘录模式](###备忘录模式)
    * [状态模式](###状态模式)
    * [解释器模式](###单一职责原则)
# 设计模式基础
## 设计原则
### 单一职责原则
一个类只负责一个职责。
### 开闭原则
一个系统应当对修改关闭对扩展开发。即扩展时不应该修改原有的代码。做一个可插拔的插口对未来的修改封闭，对扩展开发。这就要运用接口抽象更好的抽象模型。
### 里氏替换原则
在一个父类可以出现的地方都可以替换成子类。这代表可以充分复用父类。也是开闭原则的扩充。
### 依赖倒置原则
任何接口应依赖其抽象而不依赖其具体实现。该原则是开闭原则的基石，如果一个接口只依赖其具体实现。那么一旦业务改变依赖与具体实现的地方都需要修改。
### 接口隔离原则
客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。
### 迪米特原则（最少知识原则）
一个对象应该对其他对象有最少的了解。例如一个类的内部方法等尽量控制其的访问权限。私有方法一律private不暴露在外

# 23设计模式及举例
## 创建型(5种)
### 工厂模式
（Factory）

### 抽象工厂模式 
（Abstract Factory）

### 单例模式 
（Singleton）

### 构造者模式 
（Creator）

### 原型模式 
（Prototype）

## 结构型(7种)

### 适配器模式
（Adapter）　　　　　　　　
### 外观模式
（Facade）
### 桥接模式
（Bridge）
### 装饰器模式
（Decorator）
### 代理模式
（Proxy）
### 享元模式
（Flyweight）
### 组合模式
（Composite）

## 行为型(11种)

### 模板方法模式
（Template Method）

### 策略模式
（Strategy）

### 命令模式
（Command）

### 中介者模式
（Mediator）

### 观察者模式
（Observer）

### 迭代器模式
（Iteratior）

### 访问者模式
（Visiter）

### 责任链模式
（Chain of Responsibility）

### 备忘录模式
（Memento）

### 状态模式
（State）

### 解释器模式
（Interpreter）